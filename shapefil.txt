		Shapefile C Library V1.2
		========================


Purpose
-------
The Shapefile C Library provides the ability to write simple C programs
for reading, writing and updating (to a limited extent) ESRI Shapefiles,
and the associated attribute file (.dbf).


Copyright
---------
The source for the Shapefile C Library is (c) 1998 Frank Warmerdam, and placed
in the public domain.  Feel free to do anything with the source you please.
I do not assume any liability, nor express any warranty for this code.  


Manifest
--------
shapefil.txt	- This file ... documentation on the Shapefile C Library
shpopen.c	- C code for access to .shp/.shx vertex files.
dbfopen.c	- C code for access to .dbf attribute file.
shapefil.h	- Include file defining all the services of dbfopen.c and
                  shpopen.c.

dbfcreate.c	- Simple example program for creating a new .dbf file.
dbfadd.c	- Simple example program for adding a record to a .dbf file.
dbfdump.c	- Simple example program for displaying the contents of
		  a .dbf file.

shpcreate.c	- Simple example program for creating a new .shp and .shx
		  file.
shpadd.c	- Simple example program for adding a shape to an existing
		  shape file.
shpdump.c	- Simple program for dumping all the vertices in a shapefile
		  with an indicating of the parts.
shputils.c	- Complex contributed program capable of clipping and appending
                  shapefiles as well as a few other things.  Type shputils
                  after building to get a full usage message.

Makefile	- A simple makefile to compile the library and example 
		  programs.

makeshape.sh	- A simple script for running some of the example programs.

shptest.c	- A simple test harnass to generate each of the supported
		  types of shapefiles. 
stream1.sh	- A test script, which should produce stream1.out.
stream1.out	- Expected output of stream1.sh test script.
stream2.sh	- A test script, which should produce stream2.out.
stream2.out	- Expected output of stream2.sh test script.


What is a Shapefile?
--------------------
If you don't know, you probably don't need this library.  The Shapefile
format is a new working and interchange format promulagated by ESRI 
(http://www.esri.com/) for simple vector data with attributes.  It is
apparently the only file format that can be edited in ARCView 2/3, and can
also be exported and imported in Arc/Info.  

An excellent white paper on the shapefile format is available from ESRI,
but it is .pdf format, so you will need Adobe Acrobat to browse it.

The file format actually consists of three files.

XXX.shp - holds the actual vertices.
XXX.shx - hold index data pointing to the structures in the .shp file.
XXX.dbf - holds the attributes in xBase (dBase) format.  


Release Notes
-------------

Release 1.2 is mostly a rewrite of the .shp/.shx access API to account for
ArcView 3.x 3D shapes, and to encapsulate the shapes in a structure.

Release V1.1 has been built on a number of platforms, and used by a number
of people successfully.  V1.1 is the first release with the xBase API 
documentation.


Maintainer
----------
This library is maintained by me (Frank Warmerdam) on my own time.  Please 
send me bug patches and suggestions for the library.  Email can be sent to 
warmerda@home.com.

The current status of the Shapelib code can be found somewhere off my
home page at http://members.home.com/warmerda. 

The shputils.c module was contributed by Bill Miller (NC-DOT) who can be
reached at bmiller@doh.dot.state.nc.us.


Portability
-----------
The Shapefile C Library should port easily to 32bit systems with ANSI C
compilers.  It should work on 64 bit architectures (such as the DEC AXP).

Care should also be taken to pass the binary access flag into SHPOpen()
and DBFOpen() when operating on systems with special text file translation
such as MSDOS.  

The shputils.c module is contributed, and may not take the same approach
to portability as the rest of the package.


Limitations
-----------
 o You can't modify the vertices of existing structures (though you 
   can update the attributes of existing structures, and create new 
   structures).

 o Not written in such a way as to be particularly fast.

 o Doesn't set the last access time properly in the .dbf files.

 o Doesn't recover the working space in SHPGetVertices(), though the buffers
   are shared among all open files.  Usually this is only a few kilobytes.

 o There is no way to synchronize information to the file except to close it.

 o Poor error checking and reporting.

 o Not professionally supported.

 o Some aspects of xBase files not supported, though I believe they are
   not used by ESRI.

 o The application must keep the .dbf file in sync with the .shp/.shx
   files through appropriate use of the DBF and SHP APIs.



			Shapefile Library API
			=====================

The Shapefile C Library is divided into two parts, one for accessing the
vertex data in the shapefile itself (XXX.shp/XXX.shx) and one for access
the attributes in the xBase file (XXX.dbf).  

Vertex (SHP) API
----------------

The Vertex (SHP) API uses a SHPHandle to represent an open .shp/.shx file pair.
The contents of the SHPHandle are visible (see shapefile.h) but should
be ignored by the application.  It is intended that all information be
accessed by the API functions.  

                  ----------- Shape Types -------------------

  2D Shape Types (pre ArcView 3.x):

  #define SHPT_POINT		1	Points
  #define SHPT_ARC		3	Arcs (Polylines, possible in parts)
  #define SHPT_POLYGON		5	Polygons (possible in parts)
  #define SHPT_MULTIPOINT	8	MultiPoint (related points)

  3D Shape Types (may include "measure" values for vertices):

  #define SHPT_POINTZ		11	
  #define SHPT_ARCZ		13
  #define SHPT_POLYGONZ		15
  #define SHPT_MULTIPOINTZ 	18

  2D + Measure Types:

  #define SHPT_POINTM		21
  #define SHPT_ARCM		23
  #define SHPT_POLYGONM		25
  #define SHPT_MULTIPOINTM 	28

  Complex (TIN-like) with Z, and Measure:

  #define SHPT_MULTIPATCH 	31


                  ------------ SHPObject -------------------

An individual shape is represented by the SHPObject structure.  SHPObject's
created with SHPCreateObject(), SHPCreateSimpleObject(), or SHPReadObject()
should be disposed of with SHPDestroyObject().

  typedef struct
  {
    int		nSHPType;	Shape Type (SHPT_* - see list above)

    int		nShapeId; 	Shape Number (-1 is unknown/unassigned)

    int		nParts;		# of Parts (0 implies single part with no info)
    int		*panPartStart;  Start Vertex of part
    int		*panPartType;	Part Type (SHPP_RING if not SHPT_MULTIPATCH)
    
    int		nVertices;	Vertex list 
    double	*padfX;		
    double	*padfY;
    double	*padfZ;		(all zero if not provided)
    double	*padfM;		(all zero if not provided)

    double	dfXMin;		Bounds in X, Y, Z and M dimensions
    double	dfYMin;
    double	dfZMin;
    double	dfMMin;

    double	dfXMax;
    double	dfYMax;
    double	dfZMax;
    double	dfMMax;
  } SHPObject;


                  ------------------------------------------

SHPHandle SHPOpen( const char * pszShapeFile, const char * pszAccess );

  pszShapeFile:		The name of the layer to access.  This can be the
			name of either the .shp or the .shx file or can
			just be the path plus the basename of the pair.

  pszAccess:		The fopen() style access string.  At this time only
			"rb" (read-only binary) and "rb+" (read/write binary) 
		        should be used.

  The SHPOpen() function should be used to establish access to the two files
  for accessing vertices (.shp and .shx).  Note that both files have to 
  be in the indicated directory, and must have the expected extensions in
  lower case.  The returned SHPHandle is passed to other access functions, 
  and SHPClose() should be invoked to recover resources, and flush changes 
  to disk when complete.

                  ------------------------------------------

void SHPGetInfo( SHPHandle hSHP, int * pnEntities, int * pnShapeType,
                 double * padfMinBound, double * padfMaxBound );

  hSHP:			The handle previously returned by SHPOpen() 
			or SHPCreate().

  pnEntities:		A pointer to an integer into which the number of
			entities/structures should be placed.  May be NULL.

  pnShapetype:		A pointer to an integer into which the shapetype
			of this file should be placed.  Shapefiles may contain
			either SHPT_POINT, SHPT_ARC, SHPT_POLYGON or 
			SHPT_MULTIPOINT entities.

  padfMinBound:		The X, Y, Z and M minimum values will be placed into
                        this four entry array.  This may be NULL.
			
  padfMaxBound:		The X, Y, Z and M maximum values will be placed into
                        this four entry array.  This may be NULL.
			
                  ------------------------------------------

SHPObject *SHPReadObject( SHPHandle hSHP, int iShape );

  hSHP:			The handle previously returned by SHPOpen() 
			or SHPCreate().

  iShape:		The entity number of the shape to read.  Entity 
			numbers are between 0 and nEntities-1 (as returned
			by SHPGetInfo()).

  The SHPReadObject() call is used to read a single structure, or entity
  from the shapefile.  See the definition of the SHPObject structure for
  detailed information on fields of a SHPObject.  SHPObject's returned from
  SHPReadObject() should be deallocated with SHPDestroyShape().  
  SHPReadObject() will return NULL if an illegal iShape value is requested.

  Note that the bounds placed into the SHPObject are those read from the
  file, and may not be correct.   For points the bounds are generated from
  the single point since bounds aren't normally provided for point types.

                  ------------------------------------------

void	SHPClose( SHPHandle hSHP );

  hSHP:			The handle previously returned by SHPOpen() 
			or SHPCreate().

  The SHPClose() function will close the .shp and .shx files, and flush
  all outstanding header information to the files.  It will also recover
  resources associated with the handle.  After this call the hSHP handle
  cannot be used again.

                  ------------------------------------------

SHPHandle SHPCreate( const char * pszShapeFile, int nShapeType );

  pszShapeFile:		The name of the layer to access.  This can be the
			name of either the .shp or the .shx file or can
			just be the path plus the basename of the pair.

  nShapeType:		The type of shapes to be stored in the newly created
			file.  It may be either SHPT_POINT, SHPT_ARC, 
		        SHPT_POLYGON or SHPT_MULTIPOINT.

  The SHPCreate() function will create a new .shp and .shx file of the
  desired type.

                  ------------------------------------------

SHPObject * 
     SHPCreateSimpleObject( int nSHPType, int nVertices, 
			    double *padfX, double * padfY, double *padfZ, );

  nSHPType:		The SHPT_ type of the object to be created, such
                        as SHPT_POINT, or SHPT_POLYGON.
  
  nVertices:		The number of vertices being passed in padfX,    
                        padfY, and padfZ. 

  padfX:		An array of nVertices X coordinates of the vertices
                        for this object.

  padfY:		An array of nVertices Y coordinates of the vertices
                        for this object.

  padfZ:		An array of nVertices Z coordinates of the vertices
                        for this object.  This may be NULL in which case
		        they are all assumed to be zero.

  The SHPCreateSimpleObject() allows for the convenient creation of 
  simple objects.  This is normally used so that the SHPObject can be
  passed to SHPWriteObject() to write it to the file.  The simple object
  creation API assumes an M (measure) value of zero for each vertex.  For
  complex objects (such as polygons) it is assumed that there is only one
  part, and that it is of the default type (SHPP_RING). 

  Use the SHPCreateObject() function for more sophisticated objects.  The
  SHPDestroyObject() function should be used to free resources associated with
  an object allocated with SHPCreateSimpleObject(). 

  This function computes a bounding box for the SHPObject from the given 
  vertices.

                  ------------------------------------------

SHPObject * 
     SHPCreateObject( int nSHPType, int iShape,
                      int nParts, int * panPartStart, int * panPartType,
                      int nVertices, double *padfX, double * padfY, 
                      double *padfZ, double *padfM );

  nSHPType:		The SHPT_ type of the object to be created, such
                        as SHPT_POINT, or SHPT_POLYGON.

  iShape:		The shapeid to be recorded with this shape.

  nParts:		The number of parts for this object.  If this is
                        zero for ARC, or POLYGON type objects, a single 
                        zero valued part will be created internally.
  
  panPartStart:		The list of zero based start vertices for the rings
                        (parts) in this object.  The first should always be
                        zero.  This may be NULL if nParts is 0.
  
  panPartType:		The type of each of the parts.  This is only meaningful
                        for MULTIPATCH files.  For all other cases this may
                        be NULL, and will be assumed to be SHPP_RING.
  
  nVertices:		The number of vertices being passed in padfX,    
                        padfY, and padfZ. 

  padfX:		An array of nVertices X coordinates of the vertices
                        for this object.

  padfY:		An array of nVertices Y coordinates of the vertices
                        for this object.

  padfZ:		An array of nVertices Z coordinates of the vertices
                        for this object.  This may be NULL in which case
		        they are all assumed to be zero.

  padfM:		An array of nVertices M (measure values) of the 
			vertices for this object.  This may be NULL in which 
			case they are all assumed to be zero.

  The SHPCreateSimpleObject() allows for the creation of objects (shapes).  
  This is normally used so that the SHPObject can be passed to 
  SHPWriteObject() to write it to the file. 

  The SHPDestroyObject() function should be used to free resources associated 
  with an object allocated with SHPCreateObject(). 

  This function computes a bounding box for the SHPObject from the given 
  vertices.

                  ------------------------------------------

int SHPWriteObject( SHPHandle hSHP, int iShape, SHPObject *psObject );

  hSHP:			The handle previously returned by SHPOpen("r+") 
			or SHPCreate().

  iShape:		The entity number of the shape to write.  A value of
		        -1 should be used for new shapes.  

  psObject:		The shape to write to the file. This should have
                        been created with SHPCreateObject(), or 
                        SHPCreateSimpleObject().

  The SHPWriteObject() call is used to write a single structure, or entity
  to the shapefile.  See the definition of the SHPObject structure for
  detailed information on fields of a SHPObject.  The return value is the
  entity number of the written shape. 

                  ------------------------------------------

void SHPDestroyObject( SHPObject *psObject );

  psObject:		The object to deallocate.

  This function should be used to deallocate the resources associated with
  a SHPObject when it is no longer needed, including those created with
  SHPCreateSimpleObject(), SHPCreateObject() and returned from SHPReadObject().

                  ------------------------------------------

Attribute (DBF) API
-------------------

The Attribute (DBF) API uses DBFHandle to represent a handle for access
to one .dbf file.  The contents of the DBFHandle are visible (see shapefil.h)
but should be ignored by the application.  It is intended that all information
be accessed by API functions.  Note that there should be exactly one record
in the .dbf file for each shape in the .shp/.shx files.  This constraint
must be maintained by the application.

                  ------------------------------------------

DBFHandle DBFOpen( const char * pszDBFFile, const char * pszAccess );

  pszDBFFile:		The name of the xBase (.dbf) file to access.

  pszAccess:		The fopen() style access string.  At this time only
			"rb" (read-only binary) and "rb+" (read/write binary) 
		        should be used.

  The DBFOpen() function should be used to establish access to an existing
  xBase format table file.  The returned DBFHandle is passed to other 
  access functions, and DBFClose() should be invoked to recover resources, and 
  flush changes to disk when complete.  The DBFCreate() function should
  called to create new xBase files.

                  ------------------------------------------

DBFHandle DBFCreate( const char * pszDBFFile );

  pszDBFFile:		The name of the xBase (.dbf) file to create.
  
  The DBFCreate() function creates a new xBase format file with the given 
  name, and returns an access handle that can be used with other DBF functions.
  The newly created file will have no fields, and no records.  Fields should
  be added with DBFAddField() before any records add written.

                  ------------------------------------------

int DBFGetFieldCount( DBFHandle hDBF );

  hDBF:		The access handle for the file to be queried, as returned
                by DBFOpen(), or DBFCreate().

  The DBFGetFieldCount() function returns the number of fields currently
  defined for the indicated xBase file.

                  ------------------------------------------

int DBFGetRecordCount( DBFHandle hDBF );

  hDBF:		The access handle for the file to be queried, as returned by
		DBFOpen(), or DBFCreate().

  The DBFGetRecordCount() function returns the number of records that
  exist on the xBase file currently.  Note that with shape files one xBase
  record exists for each shape in the .shp/.shx files.

                  ------------------------------------------

DBFFieldType DBFGetFieldInfo( DBFHandle hDBF, int iField, char * pszFieldName,
                              int * pnWidth, int * pnDecimals );

  hDBF:		The access handle for the file to be queried, as returned by
		DBFOpen(), or DBFCreate().

  iField:	The field to be queried.  This should be a number between 
                0 and n-1, where n is the number fields on the file, as
                returned by DBFGetFieldCount().

  pszFieldName:	If this pointer is not NULL the name of the requested field
		will be written to this location.  The pszFieldName buffer 
                should be at least 12 character is size in order to hold
		the longest possible field name of 11 characters plus a 
                terminating zero character.

  pnWidth:	If this pointer is not NULL, the width of the requested field
		will be returned in the int pointed to by pnWidth.  This is
                the width in characters.  

  pnDecimals:	If this pointer is not NULL, the number of decimal places
                precision defined for the field will be returned.  This is
                zero for integer fields, or non-numeric fields.

  The DBFGetFieldInfo() returns the type of the requested field, which is
  one of the DBFFieldType enumerated values.  As well, the field name, and
  field width information can optionally be returned.  The field type returned
  does not correspond one to one with the xBase field types.  For instance
  the xBase field type for Date will just be returned as being FTInteger.  

    typedef enum {
      FTString,			/* fixed length string field 		*/
      FTInteger,		/* numeric field with no decimals 	*/
      FTDouble,			/* numeric field with decimals 		*/
      FTInvalid                 /* not a recognised field type 		*/
    } DBFFieldType;
               
                  ------------------------------------------

DBFFieldType DBFAddField( DBFHandle hDBF, const char * pszFieldName, 
                          DBFFieldType eType, int nWidth, int nDecimals );

  hDBF:		The access handle for the file to be updated, as returned by
		DBFOpen(), or DBFCreate().

  pszFieldName:	The name of the new field.  At most 11 character will be used.
                In order to use the xBase file in some packages it may be
                necessary to avoid some special characters in the field names
                such as spaces, or arithmetic operators.

  eType:	One of FTString, FTInteger or FTDouble in order to establish
                the type of the new field.  Note that some valid xBase field
                types cannot be created such as date fields.

  nWidth:	The width of the field to be created.  For FTString fields this
                establishes the maximum length of string that can be stored.
                For FTInteger this establishes the largest number that can
                be represented.  For FTDouble fields this in combination
                with the nDecimals value establish the size, and precision
                of the created field.

  nDecimals:    The number of decimal places to reserve for FTDouble fields.
                For all other field types this should be zero.  For instance
                with nWidth=7, and nDecimals=3 numbers would be formatted
                similarly to `123.456'.

  The DBFAddField() function is used to add new fields to an existing xBase
  file opened with DBFOpen(), or created with DBFCreate().  Note that fields
  can only be added to xBase files with no records, though this is limitation
  of this API, not of the file format.

  The DBFAddField() return value is the field number of the new field. 

                  ------------------------------------------

int DBFReadIntegerAttribute( DBFHandle hDBF, int iShape, int iField );
  
  hDBF:		The access handle for the file to be queried, as returned by
		DBFOpen(), or DBFCreate().

  iShape:	The record number (shape number) from which the field value
                should be read.

  iField:	The field within the selected record that should be read.

  The DBFReadIntegerAttribute() will read the value of one numeric
  (FTInteger, or FTDouble) field, and return the value as an integer.  

                  ------------------------------------------

double DBFReadDoubleAttribute( DBFHandle hDBF, int iShape, int iField );
  
  hDBF:		The access handle for the file to be queried, as returned by
		DBFOpen(), or DBFCreate().

  iShape:	The record number (shape number) from which the field value
                should be read.

  iField:	The field within the selected record that should be read.

  The DBFReadDoubleAttribute() will read the value of one numeric
  (FTInteger, or FTDouble) field, and return the value as a double precision
  number.

                  ------------------------------------------

const char *DBFReadStringAttribute( DBFHandle hDBF, int iShape, int iField );
  
  hDBF:		The access handle for the file to be queried, as returned by
		DBFOpen(), or DBFCreate().

  iShape:	The record number (shape number) from which the field value
                should be read.

  iField:	The field within the selected record that should be read.

  The DBFReadStringAttribute() will read the value of one string (FTString)
  field, and return the value.  The returned pointer is to an internal buffer
  which is only valid untill the next DBF function call.  It's contents may
  be copied with normal string functions such as strcpy(), or strdup().

                  ------------------------------------------

int DBFWriteIntegerAttribute( DBFHandle hDBF, int iShape, int iField,
                              int nFieldValue );

  hDBF:		The access handle for the file to be written, as returned by
		DBFOpen(), or DBFCreate().

  iShape:	The record number (shape number) to which the field value
                should be written.

  iField:	The field within the selected record that should be written.

  nFieldValue:	The integer value that should be written.

The DBFWriteIntegerAttribute() function is used to write a value to a numeric
field (FTInteger, or FTDouble).  If the write succeeds the value TRUE will
be returned, otherwise FALSE will be returned.  The value may be truncated 
without warning if written to a field to narrow to represent the value.

                  ------------------------------------------

int DBFWriteDoubleAttribute( DBFHandle hDBF, int iShape, int iField,
                             double dFieldValue );

  hDBF:		The access handle for the file to be written, as returned by
		DBFOpen(), or DBFCreate().

  iShape:	The record number (shape number) to which the field value
                should be written.

  iField:	The field within the selected record that should be written.

  dFieldValue:	The floating point value that should be written.

The DBFWriteDoubleAttribute() function is used to write a value to a numeric
field (FTInteger, or FTDouble).  If the write succeeds the value TRUE will
be returned, otherwise FALSE will be returned.  The value may be truncated 
without warning if written to a field to narrow to represent the value.

                  ------------------------------------------

int DBFWriteStringAttribute( DBFHandle hDBF, int iShape, int iField,
                             const char * pszFieldValue );

  hDBF:		The access handle for the file to be written, as returned by
		DBFOpen(), or DBFCreate().

  iShape:	The record number (shape number) to which the field value
                should be written.

  iField:	The field within the selected record that should be written.

  pszFieldValue: The string to be written to the field.

The DBFWriteStringAttribute() function is used to write a value to a string
field (FString).  If the write succeeds the value TRUE willbe returned, 
otherwise FALSE will be returned.  The value may be truncated 
without warning if written to a field to narrow to hold the string.

                  ------------------------------------------

void DBFClose( DBFHandle hDBF );

  hDBF:		The access handle for the file to be closed.

  The DBFClose() function will close the indicated xBase file (opened with
  DBFOpen(), or DBFCreate()), flushing out all information to the file on
  disk, and recovering any resources associated with having the file open.
  The file handle (hDBF) should not be used again with the DBF API after
  calling DBFClose().





