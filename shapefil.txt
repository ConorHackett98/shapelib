		Shapefile C Library V1.1
		========================


Purpose
-------
The Shapefile C Library provides the ability to write simple C programs
for reading, writing and updating (to a limited extent) ESRI Shapefiles,
and the associated attribute file (.dbf).


Copyright
---------
The source for the Shapefile C Library is (c) 1995 Frank Warmerdam, and placed
in the public domain.  Feel free to do anything with the source you please.
Neither I, nor PCI assume any liability, nor express any warranty for this 
code.  


Manifest
--------
shapefil.txt	- This file ... documentation on the Shapefile C Library
shpopen.c	- C code for access to .shp/.shx vertex files.
dbfopen.c	- C code for access to .dbf attribute file.
shapefil.h	- Include file defining all the services of dbfopen.c and
                  shpopen.c.

dbfcreate.c	- Simple example program for creating a new .dbf file.
dbfadd.c	- Simple example program for adding a record to a .dbf file.
dbfdump.c	- Simple example program for displaying the contents of
		  a .dbf file.

shpcreate.c	- Simple example program for creating a new .shp and .shx
		  file.
shpadd.c	- Simple example program for adding a shape to an existing
		  shape file.
shpdump.c	- Simple program for dumping all the vertices in a shapefile
		  with an indicating of the parts.

Makefile	- A simple makefile to compile the library and example 
		  programs.

makeshape.sh	- A simple script for running some of the example programs.


What is a Shapefile?
--------------------
If you don't know, you probably don't need this library.  The Shapefile
format is a new working and interchange format promulagated by ESRI 
(http://www.esri.com/) for simple vector data with attributes.  It is
apparently the only file format that can be edited in ARCView 2, and can
also be exported and imported in ARC/Info.  

An excellent white paper on the shapefile format is available from ESRI,
but it is .pdf format, so you will need Adobe Acrobat to browse it.  The
document is at url ftp://ftp.esri.com/pub/marketing/white_papers/av_shape.pdf
and Adobe Acrobat (freeware) can be found at Adobe, perhaps at the url
ftp://ftp.adobe.com/pub/adobe/Applications/Acrobat/.

The file format actually consists of three files.

XXX.shp - holds the actual vertices.
XXX.shx - hold index data pointing to the structures in the .shp file.
XXX.dbf - holds the attributes in xBase (dBase) format.  


Release Notes
-------------
Release V1.1 has been built on a number of platforms, and used by a number
of people successfully.  V1.1 is the first release with the xBase API 
documentation.


Maintainer
----------
This library is maintained by Frank Warmerdam (http://www.pci.on.ca/~warmerda)
of PCI (http://www.pci.on.ca/) on his own time.  Please send me bug patches
and suggestions for the library.  Email can be sent to warmerda@leto.pci.on.ca.


Portability
-----------
The Shapefile C Library should port easily to 32bit systems with ANSI C
compilers.  The code is not compatible with K&R C compilers (such as the
stock C compiler on SunOS 4.x), and I don't really want to mess it up
with support for K&R C.  It should work on 64 bit architectures (such 
as the DEC AXP), and has reportedly worked on 16 bit systems (Borland C)
as well as long as int32 gets properly defined in shpopen.c.

Care should also be taken to pass the binary access flag into SHPOpen()
and DBFOpen() when operating on systems with special text file translation
such as MSDOS.  


Limitations
-----------
 o You can't modify the vertices of existing structures (though you 
   can update the attributes of existing structures, and create new 
   structures).

 o Not written in such a way as to be particularly fast.

 o Doesn't set the last access time properly in the .dbf files.

 o Doesn't recover the working space in SHPGetVertices(), though the buffers
   are shared among all open files.  Usually this is only a few kilobytes.

 o There is no way to synchronize information to the file except to close it.

 o Poor error checking and reporting.

 o Not professionally supported.

 o Some aspects of xBase files not supported, though I believe they are
   not used by ESRI.

 o The application must keep the .dbf file in sync with the .shp/.shx
   files through appropriate use of the DBF and SHP APIs.



			Shapefile Library API
			=====================

The Shapefile C Library is divided into two parts, one for accessing the
vertex data in the shapefile itself (XXX.shp/XXX.shx) and one for access
the attributes in the xBase file (XXX.dbf).  

Vertex (SHP) API
----------------

The Vertex (SHP) API uses a SHPHandle to represent an open .shp/.shx file pair.
The contents of the SHPHandle are visible (see shapefile.h) but should
be ignored by the application.  It is intended that all information be
accessed by the API functions.

                  ------------------------------------------

SHPHandle SHPOpen( const char * pszShapeFile, const char * pszAccess );

  pszShapeFile:		The name of the layer to access.  This can be the
			name of either the .shp or the .shx file or can
			just be the path plus the basename of the pair.

  pszAccess:		The fopen() style access string.  At this time only
			"rb" (read-only binary) and "rb+" (read/write binary) 
		        should be used.

  The SHPOpen() function should be used to establish access to the two files
  for accessing vertices (.shp and .shx).  Note that both files have to 
  be in the indicated directory, and must have the expected extensions in
  lower case.  The returned SHPHandle is passed to other access functions, 
  and SHPClose() should be invoked to recover resources, and flush changes 
  to disk when complete.


void SHPGetInfo( SHPHandle hSHP, int * pnEntities, int * pnShapeType );

  hSHP:			The handle previously returned by SHPOpen() 
			or SHPCreate().

  pnEntities:		A pointer to an integer into which the number of
			entities/structures should be placed.  May be NULL.

  pnShapetype:		A pointer to an integer into which the shapetype
			of this file should be placed.  Shapefiles may contain
			either SHPT_POINT, SHPT_ARC, SHPT_POLYGON or 
			SHPT_MULTIPOINT entities.
			
                  ------------------------------------------

double *SHPReadVertices( SHPHandle hSHP, int iShape, int *pnVCount,
	 		 int * pnPartCount, int ** ppanParts );

  hSHP:			The handle previously returned by SHPOpen() 
			or SHPCreate().

  iShape:		The entity number of the shape to read.  Entity 
			numbers are between 0 and nEntities-1 (as returned
			by SHPGetInfo()).

  pnVCount:		Pointer to an integer into which the number of 
			vertices can be placed.  Currently must not be NULL.

  pnPartCount:		Pointer to an integer into which the number of
			``parts'' should be placed.  This may be NULL
			for SHPT_POINT and SHPT_MULTIPOINT files which
			don't have parts.

  ppanParts:		Pointer to a pointer to integers.  This pointer will
			be assigned to point to an internal array of parts
			managed by SHPReadVertices().  

  The SHPReadVertices() call is used to read a single structure, or entity
  from the shapefile.  A shape may consists of multiple parts (the outline
  and interior holes for a polygon) which will be indicated by the ppanParts
  values returned.   The values returned in ppanParts will be the offsets
  to the first vertex of each part.

  The return value of SHPReadVertices() is a pointer to an internally managed
  list of vertices.  Note that the values returned as ppanParts and the vertex
  list are only valid untill the next call to SHPReadVertices() at which point
  the internal buffers will be reused.

                  ------------------------------------------

void SHPReadBounds( SHPHandle hSHP, int iShape, double *padBounds );

  hSHP:			The handle previously returned by SHPOpen() 
			or SHPCreate().

  iShape:		The entity number of the shape to read.  Entity 
			numbers are between 0 and nEntities-1 (as returned
			by SHPGetInfo()).  If an iShape value of -1 is passed
			the bounds information for the entire file will be
			returned.

  padBounds:		A array of four doubles in which the bounds of this
			shape (or whole file) are stored in the order
			X Minimum, Y Minumum, X Maximum and Y Maximum.

  The SHPReadBounds() call is used to read a the bounds of a single structure,
  or all structures in the file if iShape is -1.  These bounds are actually 
  stored in the shape file for all shape types except points.  For points
  a bounds the bounds are computed based on the point.

                  ------------------------------------------

void	SHPClose( SHPHandle hSHP );

  hSHP:			The handle previously returned by SHPOpen() 
			or SHPCreate().

  The SHPClose() function will close the .shp and .shx files, and flush
  all outstanding header information to the files.  It will also recover
  resources associated with the handle.  After this call the hSHP handle
  cannot be used again.

                  ------------------------------------------

SHPHandle SHPCreate( const char * pszShapeFile, int nShapeType );

  pszShapeFile:		The name of the layer to access.  This can be the
			name of either the .shp or the .shx file or can
			just be the path plus the basename of the pair.

  nShapeType:		The type of shapes to be stored in the newly created
			file.  It may be either SHPT_POINT, SHPT_ARC, 
		        SHPT_POLYGON or SHPT_MULTIPOINT.

  The SHPCreate() function will create a new .shp and .shx file of the
  desired type.

                  ------------------------------------------

int SHPWriteVertices( SHPHandle hSHP, int nVCount, int nPartCount,
	              int * panParts, double * padVertices );

  hSHP:			The handle previously returned by SHPOpen() 
			or SHPCreate().

  nVCount:		The number of vertices in padVertices.  

  nPartCount:		The number of parts found in panParts.  Should
			be zero for SHPT_POINT and SHPT_MULTIPOINT.

  panParts:		List of parts, may be NULL for SHPT_POINT and
			SHPT_MULTIPOINT.  For SHPT_ARC and SHPT_POLYGON
			it must have at least one entry (0) indicating that
			the first part starts at the zeroth vertex.

  padVertices:		The list of vertices (nVCount * 2 doubles). 

  The SHPWriteVertices() function is used to write a new entity/shape to
  a shape file created with SHPCreate(), or opened with the "r+" access string
  in SHPOpen().  

  The return value of this function is the entity number of the newly written
  shapefile which will always be the new number of entities less one.
 
                  ------------------------------------------

Attribute (DBF) API
-------------------

Please see the shapefil.h include file, and dbfcreate.c, dbfadd.c and dbfdump.c
example applications for hints on how to use the DBF interface.  I hope to
document the DBP api here in the future.  Let me know (warmerda@leto.pci.on.ca)
if you would like this to happen.

                  ------------------------------------------

DBFHandle DBFOpen( const char * pszDBFFile, const char * pszAccess );

  pszDBFFile:		The name of the xBase (.dbf) file to access.

  pszAccess:		The fopen() style access string.  At this time only
			"rb" (read-only binary) and "rb+" (read/write binary) 
		        should be used.

  The DBFOpen() function should be used to establish access to an existing
  xBase format table file.  The returned DBFHandle is passed to other 
  access functions, and DBFClose() should be invoked to recover resources, and 
  flush changes to disk when complete.  The DBFCreate() function should
  called to create new xBase files.

                  ------------------------------------------

DBFHandle DBFCreate( const char * pszDBFFile );

  pszDBFFile:		The name of the xBase (.dbf) file to create.
  
  The DBFCreate() function creates a new xBase format file with the given 
  name, and returns an access handle that can be used with other DBF functions.
  The newly created file will have no fields, and no records.  Fields should
  be added with DBFAddField() before any records add written.

                  ------------------------------------------

int DBFGetFieldCount( DBFHandle hDBF );

  hDBF:		The access handle for the file to be queried, as returned
                by DBFOpen(), or DBFCreate().

  The DBFGetFieldCount() function returns the number of fields currently
  defined for the indicated xBase file.

                  ------------------------------------------

int DBFGetRecordCount( DBFHandle hDBF );

  hDBF:		The access handle for the file to be queried, as returned by
		DBFOpen(), or DBFCreate().

  The DBFGetRecordCount() function returns the number of records that
  exist on the xBase file currently.  Note that with shape files one xBase
  record exists for each shape in the .shp/.shx files.

                  ------------------------------------------

DBFFieldType DBFGetFieldInfo( DBFHandle hDBF, int iField, char * pszFieldName,
                              int * pnWidth, int * pnDecimals );

  hDBF:		The access handle for the file to be queried, as returned by
		DBFOpen(), or DBFCreate().

  iField:	The field to be queried.  This should be a number between 
                0 and n-1, where n is the number fields on the file, as
                returned by DBFGetFieldCount().

  pszFieldName:	If this pointer is not NULL the name of the requested field
		will be written to this location.  The pszFieldName buffer 
                should be at least 12 character is size in order to hold
		the longest possible field name of 11 characters plus a 
                terminating zero character.

  pnWidth:	If this pointer is not NULL, the width of the requested field
		will be returned in the int pointed to by pnWidth.  This is
                the width in characters.  

  pnDecimals:	If this pointer is not NULL, the number of decimal places
                precision defined for the field will be returned.  This is
                zero for integer fields, or non-numeric fields.

  The DBFGetFieldInfo() returns the type of the requested field, which is
  one of the DBFFieldType enumerated values.  As well, the field name, and
  field width information can optionally be returned.  The field type returned
  does not correspond one to one with the xBase field types.  For instance
  the xBase field type for Date will just be returned as being FTInteger.  

    typedef enum {
      FTString,			/* fixed length string field 		*/
      FTInteger,		/* numeric field with no decimals 	*/
      FTDouble,			/* numeric field with decimals 		*/
      FTInvalid                 /* not a recognised field type 		*/
    } DBFFieldType;
               
                  ------------------------------------------

DBFFieldType DBFAddField( DBFHandle hDBF, const char * pszFieldName, 
                          DBFFieldType eType, int nWidth, int nDecimals );

  hDBF:		The access handle for the file to be updated, as returned by
		DBFOpen(), or DBFCreate().

  pszFieldName:	The name of the new field.  At most 11 character will be used.
                In order to use the xBase file in some packages it may be
                necessary to avoid some special characters in the field names
                such as spaces, or arithmetic operators.

  eType:	One of FTString, FTInteger or FTDouble in order to establish
                the type of the new field.  Note that some valid xBase field
                types cannot be created such as date fields.

  nWidth:	The width of the field to be created.  For FTString fields this
                establishes the maximum length of string that can be stored.
                For FTInteger this establishes the largest number that can
                be represented.  For FTDouble fields this in combination
                with the nDecimals value establish the size, and precision
                of the created field.

  nDecimals:    The number of decimal places to reserve for FTDouble fields.
                For all other field types this should be zero.  For instance
                with nWidth=7, and nDecimals=3 numbers would be formatted
                similarly to `123.456'.

  The DBFAddField() function is used to add new fields to an existing xBase
  file opened with DBFOpen(), or created with DBFCreate().  Note that fields
  can only be added to xBase files with no records, though this is limitation
  of this API, not of the file format.

  The DBFAddField() return value is the field number of the new field. 

                  ------------------------------------------

int DBFReadIntegerAttribute( DBFHandle hDBF, int iShape, int iField );
  
  hDBF:		The access handle for the file to be queried, as returned by
		DBFOpen(), or DBFCreate().

  iShape:	The record number (shape number) from which the field value
                should be read.

  iField:	The field within the selected record that should be read.

  The DBFReadIntegerAttribute() will read the value of one numeric
  (FTInteger, or FTDouble) field, and return the value as an integer.  

                  ------------------------------------------

double DBFReadDoubleAttribute( DBFHandle hDBF, int iShape, int iField );
  
  hDBF:		The access handle for the file to be queried, as returned by
		DBFOpen(), or DBFCreate().

  iShape:	The record number (shape number) from which the field value
                should be read.

  iField:	The field within the selected record that should be read.

  The DBFReadDoubleAttribute() will read the value of one numeric
  (FTInteger, or FTDouble) field, and return the value as a double precision
  number.

                  ------------------------------------------

const char *DBFReadStringAttribute( DBFHandle hDBF, int iShape, int iField );
  
  hDBF:		The access handle for the file to be queried, as returned by
		DBFOpen(), or DBFCreate().

  iShape:	The record number (shape number) from which the field value
                should be read.

  iField:	The field within the selected record that should be read.

  The DBFReadStringAttribute() will read the value of one string (FTString)
  field, and return the value.  The returned pointer is to an internal buffer
  which is only valid untill the next DBF function call.  It's contents may
  be copied with normal string functions such as strcpy(), or strdup().

                  ------------------------------------------

int DBFWriteIntegerAttribute( DBFHandle hDBF, int iShape, int iField,
                              int nFieldValue );

  hDBF:		The access handle for the file to be written, as returned by
		DBFOpen(), or DBFCreate().

  iShape:	The record number (shape number) to which the field value
                should be written.

  iField:	The field within the selected record that should be written.

  nFieldValue:	The integer value that should be written.

The DBFWriteIntegerAttribute() function is used to write a value to a numeric
field (FTInteger, or FTDouble).  If the write succeeds the value TRUE will
be returned, otherwise FALSE will be returned.  The value may be truncated 
without warning if written to a field to narrow to represent the value.

                  ------------------------------------------

int DBFWriteDoubleAttribute( DBFHandle hDBF, int iShape, int iField,
                             double dFieldValue );

  hDBF:		The access handle for the file to be written, as returned by
		DBFOpen(), or DBFCreate().

  iShape:	The record number (shape number) to which the field value
                should be written.

  iField:	The field within the selected record that should be written.

  dFieldValue:	The floating point value that should be written.

The DBFWriteDoubleAttribute() function is used to write a value to a numeric
field (FTInteger, or FTDouble).  If the write succeeds the value TRUE will
be returned, otherwise FALSE will be returned.  The value may be truncated 
without warning if written to a field to narrow to represent the value.

                  ------------------------------------------

int DBFWriteStringAttribute( DBFHandle hDBF, int iShape, int iField,
                             const char * pszFieldValue );

  hDBF:		The access handle for the file to be written, as returned by
		DBFOpen(), or DBFCreate().

  iShape:	The record number (shape number) to which the field value
                should be written.

  iField:	The field within the selected record that should be written.

  pszFieldValue: The string to be written to the field.

The DBFWriteStringAttribute() function is used to write a value to a string
field (FString).  If the write succeeds the value TRUE willbe returned, 
otherwise FALSE will be returned.  The value may be truncated 
without warning if written to a field to narrow to hold the string.

                  ------------------------------------------

void DBFClose( DBFHandle hDBF );

  hDBF:		The access handle for the file to be closed.

  The DBFClose() function will close the indicated xBase file (opened with
  DBFOpen(), or DBFCreate()), flushing out all information to the file on
  disk, and recovering any resources associated with having the file open.
  The file handle (hDBF) should not be used again with the DBF API after
  calling DBFClose().





